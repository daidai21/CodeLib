#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import included.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class EnumExample:
  SUCCEED = 0
  FAILED = 1

  _VALUES_TO_NAMES = {
    0: "SUCCEED",
    1: "FAILED",
  }

  _NAMES_TO_VALUES = {
    "SUCCEED": 0,
    "FAILED": 1,
  }


class BaseTypeExample:
  """
  Attributes:
   - bool_type
   - byte_type
   - i16_type
   - i32_type
   - i64_type
   - double_type
   - string_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'bool_type', None, False, ), # 1
    (2, TType.BYTE, 'byte_type', None, None, ), # 2
    (3, TType.I16, 'i16_type', None, None, ), # 3
    (4, TType.I32, 'i32_type', None, None, ), # 4
    (5, TType.I64, 'i64_type', None, None, ), # 5
    (6, TType.DOUBLE, 'double_type', None, None, ), # 6
    (7, TType.STRING, 'string_type', None, None, ), # 7
  )

  def __init__(self, bool_type=thrift_spec[1][4], byte_type=None, i16_type=None, i32_type=None, i64_type=None, double_type=None, string_type=None,):
    self.bool_type = bool_type
    self.byte_type = byte_type
    self.i16_type = i16_type
    self.i32_type = i32_type
    self.i64_type = i64_type
    self.double_type = double_type
    self.string_type = string_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.bool_type = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.byte_type = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.i16_type = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.i32_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.i64_type = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.DOUBLE:
          self.double_type = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.string_type = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BaseTypeExample')
    if self.bool_type is not None:
      oprot.writeFieldBegin('bool_type', TType.BOOL, 1)
      oprot.writeBool(self.bool_type)
      oprot.writeFieldEnd()
    if self.byte_type is not None:
      oprot.writeFieldBegin('byte_type', TType.BYTE, 2)
      oprot.writeByte(self.byte_type)
      oprot.writeFieldEnd()
    if self.i16_type is not None:
      oprot.writeFieldBegin('i16_type', TType.I16, 3)
      oprot.writeI16(self.i16_type)
      oprot.writeFieldEnd()
    if self.i32_type is not None:
      oprot.writeFieldBegin('i32_type', TType.I32, 4)
      oprot.writeI32(self.i32_type)
      oprot.writeFieldEnd()
    if self.i64_type is not None:
      oprot.writeFieldBegin('i64_type', TType.I64, 5)
      oprot.writeI64(self.i64_type)
      oprot.writeFieldEnd()
    if self.double_type is not None:
      oprot.writeFieldBegin('double_type', TType.DOUBLE, 6)
      oprot.writeDouble(self.double_type)
      oprot.writeFieldEnd()
    if self.string_type is not None:
      oprot.writeFieldBegin('string_type', TType.STRING, 7)
      oprot.writeString(self.string_type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.bool_type)
    value = (value * 31) ^ hash(self.byte_type)
    value = (value * 31) ^ hash(self.i16_type)
    value = (value * 31) ^ hash(self.i32_type)
    value = (value * 31) ^ hash(self.i64_type)
    value = (value * 31) ^ hash(self.double_type)
    value = (value * 31) ^ hash(self.string_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BaseRequest:
  """
  Attributes:
   - traceId
   - param
   - param2
   - userId
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'traceId', None, None, ), # 1
    (2, TType.DOUBLE, 'param', None, None, ), # 2
    (3, TType.I32, 'param2', None,     0, ), # 3
    (4, TType.I64, 'userId', None, None, ), # 4
  )

  def __init__(self, traceId=None, param=None, param2=thrift_spec[3][4], userId=None,):
    self.traceId = traceId
    self.param = param
    self.param2 = param2
    self.userId = userId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.traceId = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.param = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.param2 = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.userId = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BaseRequest')
    if self.traceId is not None:
      oprot.writeFieldBegin('traceId', TType.STRING, 1)
      oprot.writeString(self.traceId)
      oprot.writeFieldEnd()
    if self.param is not None:
      oprot.writeFieldBegin('param', TType.DOUBLE, 2)
      oprot.writeDouble(self.param)
      oprot.writeFieldEnd()
    if self.param2 is not None:
      oprot.writeFieldBegin('param2', TType.I32, 3)
      oprot.writeI32(self.param2)
      oprot.writeFieldEnd()
    if self.userId is not None:
      oprot.writeFieldBegin('userId', TType.I64, 4)
      oprot.writeI64(self.userId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.traceId is None:
      raise TProtocol.TProtocolException(message='Required field traceId is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.traceId)
    value = (value * 31) ^ hash(self.param)
    value = (value * 31) ^ hash(self.param2)
    value = (value * 31) ^ hash(self.userId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BaseResponse:
  """
  Attributes:
   - succeed
   - errorCode
   - errorMessage
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'succeed', None, None, ), # 1
    (2, TType.I64, 'errorCode', None, None, ), # 2
    (3, TType.STRING, 'errorMessage', None, None, ), # 3
    (4, TType.STRING, 'data', None, None, ), # 4
  )

  def __init__(self, succeed=None, errorCode=None, errorMessage=None, data=None,):
    self.succeed = succeed
    self.errorCode = errorCode
    self.errorMessage = errorMessage
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.succeed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.errorCode = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.errorMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BaseResponse')
    if self.succeed is not None:
      oprot.writeFieldBegin('succeed', TType.BOOL, 1)
      oprot.writeBool(self.succeed)
      oprot.writeFieldEnd()
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I64, 2)
      oprot.writeI64(self.errorCode)
      oprot.writeFieldEnd()
    if self.errorMessage is not None:
      oprot.writeFieldBegin('errorMessage', TType.STRING, 3)
      oprot.writeString(self.errorMessage)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 4)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.succeed is None:
      raise TProtocol.TProtocolException(message='Required field succeed is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.succeed)
    value = (value * 31) ^ hash(self.errorCode)
    value = (value * 31) ^ hash(self.errorMessage)
    value = (value * 31) ^ hash(self.data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class BaseException(TException):
  """
  Attributes:
   - errorCode
   - errorMessage
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'errorCode', None, None, ), # 1
    (2, TType.STRING, 'errorMessage', None, None, ), # 2
    (3, TType.STRING, 'data', None, None, ), # 3
  )

  def __init__(self, errorCode=None, errorMessage=None, data=None,):
    self.errorCode = errorCode
    self.errorMessage = errorMessage
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.errorCode = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errorMessage = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('BaseException')
    if self.errorCode is not None:
      oprot.writeFieldBegin('errorCode', TType.I64, 1)
      oprot.writeI64(self.errorCode)
      oprot.writeFieldEnd()
    if self.errorMessage is not None:
      oprot.writeFieldBegin('errorMessage', TType.STRING, 2)
      oprot.writeString(self.errorMessage)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.errorCode is None:
      raise TProtocol.TProtocolException(message='Required field errorCode is unset!')
    if self.errorMessage is None:
      raise TProtocol.TProtocolException(message='Required field errorMessage is unset!')
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errorCode)
    value = (value * 31) ^ hash(self.errorMessage)
    value = (value * 31) ^ hash(self.data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ContainerTypeExample:
  """
  Attributes:
   - list_type
   - set_type
   - map_type
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'list_type', (TType.I64,None), None, ), # 1
    (2, TType.SET, 'set_type', (TType.STRING,None), None, ), # 2
    (3, TType.MAP, 'map_type', (TType.STRING,None,TType.BOOL,None), None, ), # 3
  )

  def __init__(self, list_type=None, set_type=None, map_type=None,):
    self.list_type = list_type
    self.set_type = set_type
    self.map_type = map_type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.list_type = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readI64();
            self.list_type.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.SET:
          self.set_type = set()
          (_etype9, _size6) = iprot.readSetBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readString();
            self.set_type.add(_elem11)
          iprot.readSetEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.map_type = {}
          (_ktype13, _vtype14, _size12 ) = iprot.readMapBegin()
          for _i16 in xrange(_size12):
            _key17 = iprot.readString();
            _val18 = iprot.readBool();
            self.map_type[_key17] = _val18
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ContainerTypeExample')
    if self.list_type is not None:
      oprot.writeFieldBegin('list_type', TType.LIST, 1)
      oprot.writeListBegin(TType.I64, len(self.list_type))
      for iter19 in self.list_type:
        oprot.writeI64(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.set_type is not None:
      oprot.writeFieldBegin('set_type', TType.SET, 2)
      oprot.writeSetBegin(TType.STRING, len(self.set_type))
      for iter20 in self.set_type:
        oprot.writeString(iter20)
      oprot.writeSetEnd()
      oprot.writeFieldEnd()
    if self.map_type is not None:
      oprot.writeFieldBegin('map_type', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.BOOL, len(self.map_type))
      for kiter21,viter22 in self.map_type.items():
        oprot.writeString(kiter21)
        oprot.writeBool(viter22)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.list_type)
    value = (value * 31) ^ hash(self.set_type)
    value = (value * 31) ^ hash(self.map_type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
