# 代理 Proxy

### 分类：

**静态代理** static proxy

对目标对象的每个方法的增强都是手动完成的。 静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。

静态代理实现步骤:定义一个接口及其实现类；创建一个代理类同样实现这个接口；将目标对象注注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。

样例见设计模式的代理模式。

**动态代理** dynamic proxy

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类。
从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

[example](../../design_pattern/Proxy/README.md)

**vs**

**JDK 动态代理和 CGLIB 动态代理对比：**

1. JDK 动态代理只能只能代理实现了接口的类，而 CGLIB 可以代理未实现任何接口的类。 另外， [CGLIB](https://github.com/cglib/cglib) 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

**静态代理和动态代理的对比**

1. 灵活性 ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. JVM 层面 ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

### 关键：

**通知**：Advice 就是会在目标方法执行前后执行的方法

通过通知和目标方法的执行顺序我们可以把通知分为五种：

* 前置通知（Before）：在目标方法执行之前执行。
* 后置通知（After）:在目标方法执行之后执行
* 后置返回通知（AfterReturning）:在目标方法返回之后执行，先执行后置通知再执行后置返回通知。
* 异常通知(AfterThrowing):在目标方法抛出异常时执行
* 环绕通知(around):在目标函数执行中执行

```java
这三种通知的执行顺序如下：try{
    try{
        // @Before
        method.invoke(..);
    }finally{
        // @After
    }
    // @AfterReturning
} catch() {
    // @AfterThrowing
}
```

**切入点**：PointCut 应用通知进行增强的目标方法

**连接点**：jointpoint 连接点就是可以应用通知进行增强的方法

**切面**：Aspect 是切入点和通知的结合

**织入**：Weaving 就是通过动态代理对目标对象方法进行增强的过程
